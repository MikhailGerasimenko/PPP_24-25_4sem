import time
import itertools
import string
import hashlib # For hashing the attempts, assuming we compare against a known hash type
import json
from typing import Optional # Moved from the bottom
from celery import shared_task, current_task
from app.core.config import settings
import redis # Relying on redislite to patch this

# Establish a Redis connection for Pub/Sub
# Uses the COMMON_REDISLITE_URL which includes ?dbfilename=...
try:
    # Ensure settings.COMMON_REDISLITE_URL is used here
    redis_client = redis.StrictRedis.from_url(settings.COMMON_REDISLITE_URL, decode_responses=True)
    redis_client.ping() # Test connection
    print(f"Celery task PubSub: Successfully connected via URL: {settings.COMMON_REDISLITE_URL}")
except Exception as e:
    print(f"Celery task PubSub: ERROR connecting via URL {settings.COMMON_REDISLITE_URL}: {e}")
    redis_client = None

NOTIFICATION_CHANNEL = "ws_notifications"

DEFAULT_CHARSET = string.ascii_letters + string.digits # Alphanumeric

# Placeholder for actual hash cracking logic (e.g., for RAR)
# This is highly dependent on the hash_type. For now, we'll simulate with SHA256.
# For a real RAR bruteforce, you'd use a library that can attempt to open RAR files with passwords.
# This example will assume the input `hash_to_crack` is a SHA256 hash of the password.

def verify_password(plain_password: str, target_hash: str, hash_type: str = "sha256"):
    if hash_type.lower() == "sha256":
        return hashlib.sha256(plain_password.encode()).hexdigest() == target_hash
    # Add other hash types here, e.g., RAR. For RAR, this would involve trying to decrypt a small header.
    # This is a major simplification for the lab's scope unless a specific RAR library is used.
    elif hash_type.lower() == "rar":
        # This is a placeholder. Real RAR cracking is complex.
        # raise NotImplementedError("RAR hash verification not implemented in this example.")
        # For simulation, let's pretend short passwords are easy to check for RAR.
        # In a real scenario, you would attempt to open the archive.
        if len(plain_password) <= 5: # Arbitrary check for simulation
             return hashlib.sha256(plain_password.encode()).hexdigest() == target_hash # Simulate with sha256
        return False
    return False


@shared_task(bind=True)
def bruteforce_task(self, client_id: str, task_id_ws: str, hash_to_crack: str, max_length: int, 
                    charset: Optional[str] = None, hash_type: str = "rar"):
    used_charset = charset if charset else DEFAULT_CHARSET
    n_chars = len(used_charset)
    start_time = time.time()

    # Send STARTED notification
    started_message = {
        "client_id": client_id,
        "payload": {
            "task_id": task_id_ws, # Use the task_id generated by FastAPI for WebSocket
            "status": "STARTED",
            "hash_type": hash_type,
            "charset_length": n_chars,
            "max_length": max_length
        }
    }
    if redis_client:
        redis_client.publish(NOTIFICATION_CHANNEL, json.dumps(started_message))
    self.update_state(state='STARTED', meta=started_message["payload"]) # Celery state

    total_combinations_to_check = sum(n_chars ** l for l in range(1, max_length + 1))
    checked_combinations = 0
    found_password = None
    last_progress_update_time = time.time()
    combinations_since_last_update = 0

    for length in range(1, max_length + 1):
        if found_password: # Stop if found by another concurrent part (not applicable here but good practice)
            break
        
        for combination_tuple in itertools.product(used_charset, repeat=length):
            if self.is_revoked():
                elapsed_time = time.time() - start_time
                revoked_message = {
                    "client_id": client_id,
                    "payload": {
                        "task_id": task_id_ws,
                        "status": "REVOKED",
                        "message": "Task was revoked by user.",
                        "elapsed_time": f"{elapsed_time:.2f}s"
                    }
                }
                if redis_client:
                    redis_client.publish(NOTIFICATION_CHANNEL, json.dumps(revoked_message))
                return {"status": "REVOKED", "message": "Task revoked."}

            current_combination_str = "".join(combination_tuple)
            checked_combinations += 1
            combinations_since_last_update += 1

            if verify_password(current_combination_str, hash_to_crack, hash_type):
                found_password = current_combination_str
                # Publish one last progress update to clear the line if using \r
                progress_percentage = (checked_combinations / total_combinations_to_check) * 100
                progress_message_payload = {
                    "task_id": task_id_ws,
                    "status": "PROGRESS",
                    "progress": round(progress_percentage, 2),
                    "current_combination": current_combination_str,
                    "combinations_per_second": 0 # Final update, CPS not relevant
                }
                if redis_client:
                    redis_client.publish(NOTIFICATION_CHANNEL, json.dumps({"client_id": client_id, "payload": progress_message_payload}))
                self.update_state(state='PROGRESS', meta=progress_message_payload)
                break # Found, break from inner loop

            current_time = time.time()
            if current_time - last_progress_update_time >= 1.0 or checked_combinations % 1000 == 0: # Update every second or 1000 combs
                progress_percentage = (checked_combinations / total_combinations_to_check) * 100
                cps = combinations_since_last_update / (current_time - last_progress_update_time) if (current_time - last_progress_update_time) > 0 else 0
                
                progress_message = {
                    "client_id": client_id,
                    "payload": {
                        "task_id": task_id_ws,
                        "status": "PROGRESS",
                        "progress": round(progress_percentage, 2),
                        "current_combination": current_combination_str, # Show last tried for verbosity
                        "combinations_per_second": round(cps, 0)
                    }
                }
                if redis_client:
                    redis_client.publish(NOTIFICATION_CHANNEL, json.dumps(progress_message))
                self.update_state(state='PROGRESS', meta=progress_message["payload"])
                last_progress_update_time = current_time
                combinations_since_last_update = 0

    elapsed_time = time.time() - start_time
    formatted_elapsed_time = time.strftime("%H:%M:%S", time.gmtime(elapsed_time))

    completed_message_payload = {
        "task_id": task_id_ws,
        "status": "COMPLETED",
        "result": found_password,
        "elapsed_time": formatted_elapsed_time
    }
    
    final_message_to_publish = {"client_id": client_id, "payload": completed_message_payload}

    if redis_client:
        redis_client.publish(NOTIFICATION_CHANNEL, json.dumps(final_message_to_publish))
    
    return completed_message_payload # This is the Celery task result

# from typing import Optional # ensure Optional is imported for the charset parameter # Removed from bottom 